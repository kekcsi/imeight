-- PRINT --

    PRINT "HELLO WORLD"
	REMARK: This instruction is for learning and debugging purposes only.
	REMARK:	Run the program then read "HELLO WORLD" printed in the Log window of your browser's Inspect panel.

An Infix Operator: + Between Numbers

    PRINT 6+4
	REMARK: See 10 printed in the log.
	REMARK: + is an infix operator and works like in maths.
	REMARK: There are more operators to be covered in the Expressions part of this tutorial.

A Function: SIN

    PRINT SIN(1.571)
	REMARK: 1.571 is approximately 90 degrees in radians. So this will print a number close to 1, sine of 90 degrees.
	REMARK: You must not leave white space between SIN and the parenthesis.



-- INPUT --

Full Syntax

	INPUT "HOW MUCH?", A
	REMARK: Again an instruction for learning purposes only. Displays a prompt window in your browser with the question "HOW MUCH?". User may enter the value.

Default Prompt

	INPUT A
	REMARK: A shorter version of the INPUT instruction. Also displays a prompt window but the question is generated by the runner.

The Normal Program Flow

	INPUT A
	PRINT A
	INPUT B
	PRINT B
	REMARK: Now we wrote a program of multiple lines. The topmost line will run first. Program waits while the user is entering the value for A.
	REMARK: Then the second line runs so the value of the variable A is printed to the log.
	REMARK: See that whatever is entered is printed. It's because INPUT instruction has assigned the entered value to the variable A, which kept that value when printed.
	REMARK: Third and fourth line does the same with another variable, B. INPUT B happens after printing A, as if you would read a story.

Assignment: Old Value, New Value

	INPUT A
	PRINT A
	INPUT A
	PRINT A
	REMARK: In the previous example A kept its value. Now here is an example how it can drop the value. Read the story.
	REMARK: First line, INPUT A prompts the user and assigns the entered value to A. Variable A will keep it for the next line.
	REMARK: To prove it, we do a PRINT A in the 2nd line. In the 3rd line INPUT will assign again. Which means, the old value
	REMARK: is replaced by the new. See what gets logged in the 4th line: the new value of A, regardless of its previous value.



-- LET --

	LET SUM = 6+4
	PRINT SUM
	REMARK: The first line will assign a calculated value, 10, to the variable SUM.
	REMARK: Second line shows that the variable keeps the value.
	REMARK: This way you can give a name to your calculation results, making your intent clear and the code maintainable.

Implicit LET Instruction

	SUM = 6+4
	PRINT SUM
	REMARK: You can omit the instruction LET and it will still be interpreted as an assignment.
	REMARK: Line 1 is not an equation. The left side must specify the thing to assign to (variable A this time.)

Motivation
	
	SUM = 1+1+1+1+1+1+1+1+1+1
	LITTLEBIGGER = SUM+1
	MUCHBIGGER = SUM+10
	PRINT SUM
	PRINT LITTLEBIGGER
	PRINT MUCHBIGGER
	REMARK: Let's pretend that calculating SUM takes a lot of time and effort.
	REMARK: This is how you reuse a calculation. The SUM variable keeps its value and is used for calculating two more values.
	REMARK: So variables are not only there for code readability, they can make your code more efficient, too.

Referencing The Old Value In LET

	INPUT A
	A = A+1
	PRINT A
	REMARK: 2nd line says, add 1 to the old value of A, and let the incremented value be the new value of A.
	REMARK: So the 3rd line will print the successor of whatever the user enters.



-- REM, The Colon, Spaces: Your Readable Code --

You can make your code self documented by inserting REM instrucions. They make the runner ignore the rest of the line.

	REM * USER WILL ENTER A NUMBER *
	INPUT A
	REM * COMPUTER WILL INCREMENT THE NUMBER *
	A = A+1
	REM * AND NOW DISPLAY THE RESULT *
	PRINT A
	
You can use this instruction to temporarily skip a line or two while developing your program:

	PRINT "HELLO"
	REM PRINT "GOODBYE"
	REM * I HAVE COMMENTED OUT THE SECOND LINE *
	REM *    RUNS LIKE IT WAS DELETED BUT      *
	REM * MAYBE I WILL WANT TO UNCOMMENT LATER *

You can normally put several instructions on a line, separated by colon:

	PRINT "HELLO":PRINT "WORLD":REM BOTH WILL PRINT

But the colon does not break the REM instruction:

	PRINT "THIS PRINTS":REM HERE IS A REMARK:PRINT "STILL PART OF THE REM, NOT PRINTING"

The REMARK lines in the examples before are also REM instructions.
The space after the REM or any instruction is optional, so the text starting with ARK had been ignored by the runner.
But you should keep your code readable, which means spaces are good for you.



-- Expressions --

	A$ = "A LITERAL IS A SIMPLE EXPRESSION."
	B$ = A$ + A$:REM A CALCULATION WITH AN OPERATOR IS AN EXPRESSION (B$= IS NOT PART OF THE EXPRESSION)
	PRINT A$ + A$:REM EXPRESSION MAY APPEAR IN ASSIGNMENT RIGHT SIDE AS WELL AS PRINT ARGUMENT
	INPUT A$ + A$, C$:REM OR ARGUMENT TO OTHER INSTRUCTIONS
	Y = SIN(1 + 0.571):REM COMBINATION OF FUNCTIONS AND OPERATORS BUILD EXPRESSIONS, TOO
	Z = SIN(4.712)+2:REM COMBINE THEM FREELY LIKE IN MATHS



String Expressions

(A) The String Literal

	A$ = "HELLO WORLD"
	PRINT "HELLO WORLD"
	PRINT A$
	REM *     THE QUOTED "HELLO WORLD" IS CALLED LITERAL     *
	REM * BECAUSE IT ASSIGNS, PRINTS "HELLO WORLD" LITERALLY *
	REM *        WHEREAS A$ IS NOT A LITERAL BECAUSE         *
	REM * IT PRINTS "HELLO WORLD" RATHER THAN "A$" LITERALLY *

(B) Concatenation

	PRINT "HELLO" + "WORLD"
	REM * PLUS BETWEEN STRING LITERALS MEANS CONCATENATION *
	REM *   PRINTS "WORLD" IMMEDIATELY FOLLOWING "HELLO"   *
	
	GREETING$ = "HELLO"
	AUDIENCE$ = "WORLD"
	PRINT GREETING$ + " " + AUDIENCE$
	REM * CONCATENATION OF STRING VARIABLES AND LITERALS ALSO WORKS *
	
(C) String Functions
	
	PRINT LEN("HOW LONG AM I"):REM PRINTS 13 (10 LETTERS + 3 SPACES)
	PRINT "1" + "2":REM DOES NOT PRINT 3 BUT A CONCATENATED STRING "12"
	PRINT VAL("1") + VAL("2"):REM PRINTS 3
	PRINT ASC("A"):REM PRINTS THE ASCII CODE 65
	PRINT CHR$(65):REM PRINTS "A" BEACUSE ITS ASCII CODE IS 65
	PRINT LEFT$("HELLO", 3):REM PRINTS "HEL" - 3 CHARACTERS FROM THE LEFT
	PRINT RIGHT$("HELLO", 3):REM PRINTS "LLO" - 3 CHARACTERS FROM THE RIGHT
	PRINT MID$("HELLO", 2, 3):REM PRINTS "ELL" - 3 CHARACTERS FROM THE 2ND POSITION
	REM * THE COMMA IS AN OPERATOR HERE THAT MAKES A PARAMETER LIST. * 
	REM *          IT IS THE LEAST BINDING OPERATOR OF ALL.          *



Numeric Expressions

(A) Literals

	MOL = 6.022E+23:REM E MEANS "TIMES 10 TO THE POWER"
	A = 10:REM DECIMAL 10, REALLY TEN
	B = %10:REM BINARY 10, MEANING TWO
	C = $10:REM HEXADECIMAL 10, MEANING SIXTEEN
	D = !10:REM FOUR-BASE 10, MEANING FOUR
	E = 1.2:REM 1 AND 2 TENTHS
	F = .2:REM 2 TENTHS
	G = .2E-2:REM 0.002

(B) Operators

	C = A+B:REM ADD
	C = A-B:REM SUBTRACT
	C = A*B:REM MULTIPLY
	C = A/B:REM DIVIDE
	C = A^B:REM POWER
	C = A AND B:REM BITWISE LOGICAL AND; SPACE IS NECESSARY AFTER A
	C = A OR B:REM BITWISE LOGICAL OR; SPACE IS NECESSARY AFTER A

(C) Functions
	REM * SOME INTERESTING THINGS THAT TECHNICALLY ARE FUNCTIONS *
	Y = -X:REM UNARY MINUS, MEANING (-1)*X
	Y = A*(B+C):REM THE PARENTHESIS IS A FUNCTION WITHOUT A NAME - RETURNS WHAT IS INSIDE
	
	REM * BASIC MATHS *
	Y = SGN(X):REM -1 FOR A NEGATIVE X, 0 FOR 0, 1 FOR A POSITIVE X
	Y = INT(X):REM INTEGER PART OF X, BUT STAYS FLOATING POINT
	Y = ABS(X):REM ABSOLUTE VALUE: -X IF X<0, OTHERWISE X
	Y = SQR(X):REM SQUARE ROOT
	
	REM * TRANSCENDENT *
	Y = LOG(X):REM NATURAL LOGARITHM
	Y = EXP(X):REM NATURAL EXPONENTIAL FUNCTION
	
	REM * TRIGONOMETRY *
	Y = COS(X):REM COSINE
	Y = SIN(X):REM SINE
	Y = TAN(X):REM TANGENT
	Y = ATN(X):REM ARC TANGENT	

	REM * COMPUTING *
	Y = NOT(X):REM BITWISE LOGICAL NEGATION
	Y = INT%(X):REM INTEGER VALUE OF X, STORED IN A 16-BIT FIXED WORD
	Y = RND(X):REM NON-NEGATIVE RANDOM NUMBER THAT IS LESS THAN X
	Y = PEEK(X):REM THE BYTE STORED IN MEMORY AT ADDRESS X; SPOILER - STORE ONE USING POKE INSTRUCTION
	Y$ = STR$(X):REM A DECIMAL REPRESENTATION OF THE NUMBER X



About Evaluation

	PRINT RND(8) - RND(8):REM RND FUNCTION GETS EVALUATED TWICE, PROBABLY RETURNS DIFFERENT VALUES
	
	X = RND(8):REM EVALUATED ONCE
	PRINT X - X:REM ALWAYS RETURNS ZERO



-- GOTO --

Flow instructions can break the normal flow of the program. GOTO instructs the runner to immediately go to a specified
point in the program, rather than continuing at the next one in reading order. Using the @ instruction you can put a
label to a point in the program and reference that label in a GOTO argument.

Jumping over a part of the program:

	PRINT "TITLE"
	PRINT "INTRODUCTION"
	GOTO RESULTS
	REM NOONE CARES ABOUT CALCULATIONS
	PRINT "CALCULATIONS"
	@RESULTS
	PRINT "RESULTS"

Jumping back makes an endless loop:

    A = 1
	@LOOP
	PRINT A
	A = A+1
	GOTO LOOP
	REM * THIS WILL RUN FOREVER *
	
Jumping wildly:

	PRINT "THEY SAY GOTO IS A CRIME"
	GOTO INTERMEZZO
	@CONTINUATION
	PRINT "CAN WE CONCLUDE, GOTO IS FUN?"
	GOTO FIN
	@INTERMEZZO
	PRINT "I SAY GOTO IS FINE"
	GOTO CONTINUATION
	@FIN



-- IF and THEN --

Logical Operators

	INPUT A
	IF A=1 THEN PRINT "A IS ONE"
	IF A<>2 THEN PRINT "A IS NOT TWO"
	IF A<10 THEN PRINT "A IS LESS THAN TEN"
	IF A>5 THEN PRINT "A IS GREATER THAN FIVE"
	IF A<=8 THEN PRINT "A IS NOT GREATER THAN EIGHT"
	IF A>=7 THEN PRINT "A IS NOT LESS THAN SEVEN"
	IF A>=4 AND A<=6 THEN PRINT "A IS BETWEEN FOUR AND SIX"
	IF A<3 OR A>9 THEN PRINT "A IS NOT BETWEEN THREE AND NINE"

Mixing Logic and Numbers

	REM * TRUE CONVERTS TO 1, FALSE TO 0 IF COMPARISON RESULT IS USED IN NUMERIC EXPRESSION *
	REM * WHEN NUMERIC EXPRESSION IS USED AS A CONDITION, 0 MEANS FALSE, NON-0 NUMBERS TRUE *
	INPUT "PLEASE ENTER 1 HERE.", A
	IF 1-A THEN PRINT "BAD"
	IF 1-A<>0 THEN PRINT "BAD"
	IF 1<>A THEN PRINT "BAD"
	REM * IF USER DOES NOT ENTER 1 THEN "BAD" APPEARS THREE TIMES *
	REM * IF USER ENTERS 1 THEN PROGRAM ENDS WITHOUT PRINTING     *

Pitfalls

	REM * OPERATORS AND, OR WORK BITWISE                                                               *
	REM * AS LONG AS THE TWO SIDES OF THEM ARE EITHER 0 OR 1, THEY CAN BE USED TO COMBINE CONDITIONS   *
	REM * COMPARISON OPERATORS LIKE < AND > AND = WILL GIVE EITHER 0 OR 1 TO SUPPORT SUCH COMBINATIONS *
	REM * HOWEVER, NOT FUNCTION IS BITWISE AND MAY HAVE ASTONISHING RESULT                             *
	INPUT A:INPUT B
	IF NOT(A=B) THEN PRINT "A IS NOT B?"
	REM * ENTER EQUAL NUMBERS                                         *
	REM * A=B GIVES 1 (TRUE). NOT(A=B) GIVES ALL BITS BUT ONE SET, -2 *
	REM * IT IS NOT 0, CONDITION IS MET, MESSAGE WILL BE PRINTED      *

	PRINT 0=0=0:REM 0 BECAUSE 0=0 GIVES 1 (TRUE), 1=0 GIVES 0 (FALSE)
	PRINT 0=0=1:REM 1 BECAUSE 0=0 GIVES 1 (TRUE), 1=1 GIVES 1 (TRUE)
	
Colon After THEN

	@TASK
	A = INT(RND(10))
	B = INT(RND(10))
	@ASK
	INPUT A + " + " + B, C
	IF C = A+B THEN PRINT "CORRECT":GOTO TASK
	PRINT "TRY AGAIN":GOTO ASK
	REM * IF THE USER INPUT IS CORRECT THEN THE PROGRAM WILL NOT ONLY PRINT "CORRECT" BUT ALSO GOTO TASK *
	REM * IF THE CONDITION IS NOT MET THEN THE REST OF THE LINE IS SKIPPED, EVEN IF IT CONTAINS          *
	REM * SEVERAL INSTRUCTIONS SEPARATED WITH COLON                                                      *



-- Operator Summary --

Precedence

	REM ^            	    LEVEL 1
	PRINT 2 * 3^2:REM 18
	PRINT (2*3)^2:REM 36
	REM / *          	    LEVEL 2
	PRINT 1 + 2*3:REM 7
	PRINT (1+2)*3:REM 9
	REM + -          	    LEVEL 3
	PRINT 6 < 10+2:REM 1
	PRINT (6<10)+2:REM 3
	REM <> >= > <= < 	    LEVEL 4
	PRINT 2 = 4<>3:REM 0
	PRINT (2=4)<>3:REM 1
	REM =            	    LEVEL 5
	PRINT 1 AND 3 = 1:REM 0
	PRINT (1 AND 3)=1:REM 1
	REM AND          	    LEVEL 6
	PRINT 1 OR 3 AND 2:REM 3
	PRINT (1 OR 3)AND 2:REM 2
	REM OR           	    LEVEL 7
	PRINT 1, 2 OR 4:REM [1, 6]
	REM , 			 	    LEVEL 8

	REM * MORE OPERATORS ON THE SAME PRECEDENCE LEVEL *
	PRINT 18 / 3^2:REM 2
	PRINT 6 + 4/2:REM 8
	PRINT 6 - 4/2:REM 4
	PRINT 6 < 10-2:REM 1
	PRINT 9 > 10-2:REM 1
	PRINT 8 <= 10-2:REM 1
	PRINT 8 >= 10-2:REM 1
	PRINT 1 = 4>3:REM 1
	PRINT 3 = 3<2:REM 0
	PRINT 1 = 4>=4:REM 1
	PRINT 0 = 1<=1:REM 0
	
Associativity
	
	REM * ALL OPERATORS LEFT-ASSOCIATIVE (INCLUDING POWER, UNLIKE IN MATHS) *
	PRINT 2^3^2:REM 64
	PRINT 2^(3^2):REM 512
	PRINT 100/20/5:REM 1
	PRINT 100/(20/5):REM 25
	PRINT 100-20-5:REM 75
	PRINT 100-(20-5):REM 85
	PRINT 3>2>1:REM 0 BECAUSE 3>2 GIVES 1 (TRUE), 1>1 GIVES 0 (FALSE)
	PRINT 3>(2>1):REM 1 BECAUSE 2>1 GIVES 1 (TRUE), 3>1 GIVES 1 (TRUE)
	
The Unary Minus Sign

	REM * UNARY MINUS HAS LOWER PRECEDENCE THAN POWER *
	PRINT -2^2:REM -4
	PRINT (-2)^2:REM 4
	REM * UNARY MINUS HAS HIGHER PRECEDENCE THAN ADD OR SUBTRACT *
	PRINT -2+2:REM 0
	PRINT -(2+2):REM -4



-- GOSUB and RETURN --

	PRINT "VERSE 1"
	GOSUB CHORUS:REM GO TO THE SUBPROGRAM AT @CHORUS BUT COME BACK WHEN IT'S DONE
	PRINT "VERSE 2"
	GOSUB CHORUS:REM NOTE THAT THE SAME SUBPROGRAM CAN RETURN HERE, TOO
	GOTO OUTRO
	@CHORUS: PRINT "CHORUS"
	RETURN:REM SUBPROGRAM OVER, GO BACK TO THE POINT AFTER GOSUB (THE RIGHT GOSUB)
	@OUTRO: PRINT "OUTRO"
	


-- END and STOP --

	PRINT "VERSE 1"
	GOSUB CHORUS
	PRINT "VERSE 2"
	GOSUB CHORUS
	PRINT "OUTRO"
	END:REM PREVENTS RUNNING THE CHORUS AGAIN
	@CHORUS: PRINT "CHORUS"
	RETURN
	
	INPUT R
	IF R<=0 THEN STOP
	PRINT R^2*3.14159
	REM * THE RUNNER CAN TELL IF THE PROGRAM STOPPED WITH ERROR OR ENDED NORMALLY *
	
	PRINT "STEP 1"
	STOP
	PRINT "STEP 2"
	STOP
	PRINT "STEP 3"
	REM * THE RUNNER CAN CONTINUE RUNNING THE PROGRAM WHERE IT STOPPED *



-- FOR and NEXT --

	FOR I=1 TO 10:PRINT I:NEXT
	
	FOR I=0 TO 9
		A$ = " "
		REM * ANOTHER LOOP INSIDE THE LOOP         *
		REM * THE END OF THE LOOP IS AN EXPRESSION *
		REM * THE COUNTER J WILL STEP DOWN         *
		FOR J=9 TO 9-I STEP -1
			A$ = A$ + J
		NEXT
		PRINT A$
	NEXT I
	REM * THIS SYNTAX OF NEXT MAKES SURE THAT IT ENDS THE CORRECT LOOP         *
	REM * IF THE PROGRAM FLOW ACCIDENTALLY HITS IT WHEN THERE IS NO LOOP FOR I *
	REM * THEN INSTEAD OF CONTINUING THE WRONG FLOW, IT IMMEDIATELY STOPS      *
	
	REM * BREAKING THE LOOP EARLY *
	INPUT CUT
	FOR I=1 TO 10
		PRINT I
		IF I = CUT THEN I = 30:NEXT:GOTO OUT
		PRINT "POTATO"
	NEXT
	@OUT
	PRINT "STEAK"
	
	FOR I=10 TO 45 STEP 10:PRINT I:NEXT
	PRINT "LOOP EXITED WITH " + I
	REM * I NEVER GETS EXACTLY 45, LAST CYCLE STARTS WITH I=40, EXITS WITH I=50 *



-- DATA and READ --

	FOR I=1 TO 5:READ A:PRINT A:NEXT
	DATA 2,3,5,7,11

	READ A:READ B:A=9:READ C
	DATA RND(8)
	DATA A, A + 1
	REM * EVALUATION ORDER: ON READ A, FIRST DATA LINE IS EVALUATED, A RANDOM NUMBER GETS GENERATED. *
	REM * ON READ B, SECOND DATA LINE EVALUATES (BOTH ELEMENTS OF IT AT ONCE.) NOW VARIABLE A HOLDS  *
	REM * THE RANDOMIZED NUMBER, SO B GETS THE SAME VALUE AS A. THEN A=9 ASSIGNMENT HAPPENS.         *
	REM * C GETS THE ALREADY EVALUATED VALUE, WHICH IS THE RANDOM NUMBER PLUS 1 (THE NEW VALUE OF A, *
	REM * 9, DOES NOT AFFECT C'S.)                                                                   *
	


-- RESTORE --

Restore to the beginning

	GOSUB POEM
	PRINT "*"
	GOSUB POEM
	END
	@POEM
	RESTORE
	REM * RESTORE INSTRUCTION MAKES SURE THE POEM STARTS WITH THE FIRST LINE *
	REM *      NO MATTER HOW MANY TIMES THE PROGRAM RUNS THE SUBPROGRAM      *
	FOR LINE=1 TO 5:READ L$:PRINT L$:NEXT LINE
	RETURN
	DATA "THERE WAS AN OLD MAN WITH A BEARD,"
	DATA "WHO SAID, 'IT IS JUST AS I FEARED!"
	DATA "TWO OWLS AND A HEN,", "FOUR LARKS AND A WREN,"
	DATA "HAVE ALL BUILT THEIR NESTS IN MY BEARD!'"
	
Restore to a label

	RESTORE WEEKEND
	FOR I=1 TO 14
		READ DAY$:PRINT DAY$
		IF DAY$ = "SUN" THEN RESTORE
	NEXT
	END
	DATA "MON", "TUE", "WED", "THU", "FRI"
	@WEEKEND: DATA "SAT", "SUN"



-- DIM --

	REM * BUBBLE SORT *
	DIM ARRAY(10)
	INPUT ARRAY(0)
	FOR I=1 TO 9
		READ ARRAY(I)
	NEXT
	FOR K=8 TO 0 STEP -1
		FOR I=0 TO K
			IF ARRAY(I)>ARRAY(I + 1) THEN NEXT I:GOTO OUT
			SWAP = ARRAY(I)
			ARRAY(I) = ARRAY(I + 1)
			ARRAY(I + 1) = SWAP
		NEXT I
		@OUT
		PRINT ARRAY(I)
	NEXT K
	PRINT ARRAY(0)
	END
	DATA 1, 2, 3, 5, 9, 8, 7, 4, 6



-- POKE --

	POKE 5000,6
	PRINT PEEK(5000)



-- CLR --

	PI = 3.0
	PRINT PI
	CLR
	PRINT PI



-- DEF --

	LOG2 = LOG(2)
	DEF LOG2(X) = LOG(X)/LOG2
	X=10
	PRINT LOG2(32)
	PRINT X



-- ON --

	INPUT "CHOOSE FROM MENU 1-3", CHOICE
	ON CHOICE GOTO M1, M2, M3
	@M1: PRINT "YOU CHOSE #1"
	END
	@M2: PRINT "YOU CHOSE #2"
	END
	@M3: PRINT "YOU CHOSE #3"
	END

	@START
	INPUT "CHOOSE FROM MENU 1-3", CHOICE
	ON CHOICE GOSUB M1, M2, M3
	GOTO START
	@M1: PRINT "YOU CHOSE #1"
	END
	@M2: PRINT "YOU CHOSE #2"
	END
	@M3: PRINT "YOU CHOSE #3"
	END	



-- I/O: OPEN, CLOSE, GET, WAIT --



-- Abbreviations --

	INPUT "ENTER REQUESTED INDIAN COUNT", N
	IF N>10 T.G.HANDLER
	S$=""
	FOR I=1 TO N
		GOSUB INDIAN
		S$="S"
	N.
	END
	@HANDLER: 
		PRINT "TOO MANY INDIANS"
		STOP
	@INDIAN: 
		PRINT I+" LITTLE INDIAN"+S$
		R.



-- Run Time Errors --

NO VALUE

	CLR
	PRINT NOSUCH
	
	DATA XX+1, YY+1
	XX=0
	READ Y:REM TRIES TO EVALUATE THE WHOLE DATA LINE, INCLUDING YY+1
	YY=0:REM TOO LATE

INVALID REFERENCE

	CLR
	INPUT UNARRAY(0)
	
	SIN(0) = 0

NEXT WITHOUT FOR

	FOR I=0 TO 10
		IF I=5 THEN I=10:NEXT
		REM *     WHAT HAPPENS WHEN I=5? IF CONDITION MET, I GETS 10    *
		REM *    NEXT ABOVE WILL TERMINATE THE LOOP AND CONTINUE HERE   *
		REM * THE OTHER NEXT WILL ALSO RUN BUT THERE IS NO LOOP ANYMORE *
	NEXT

LOOP MISMATCH

	FOR I=1 TO 10:NEXT J

OVERDEFINITION

	DIM SIN(10)

OUT OF DATA

	REM * OOPS, OFF BY ONE *
	FOR I=0 TO 10:READ X:NEXT
	DATA 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

NO DATA AT LABEL

	RESTORE LABEL
	@LABEL:PRINT "NOT A DATA INSTRUCTION"
	DATA 1

LABEL DOES NOT EXIST

	GOTO PI
	
	GOSUB PI
	
	RESTORE PI

DIVIDE BY ZERO

	A = 1/0

-- Contrasting C64 --

Dollar or percent sign at the end of names is a convention

	A% = "HELLO"
	A$ = 3
	REM * BOTH WORK *
	
The full name of the variable identifies

	VAR1 = 1:VAR2 = 2:REM TWO DISTINCT VARIABLES HERE

Use spaces to separate names from operators

	SCORE = 30
	SC = 1:E = 2
	PRINT SCORE:REM 30
	PRINT SC OR E:REM 3

DATA lines may contain expressions and are evaluated when READ
	
Line numbers replaced by labels

Linked list of numbered lines replaced by label hashtable, else branch map and read data pointers

Tokenized program text is in postfix order to make runner simpler and faster

Abbreviations: T. for THEN, G. for GOTO, and N. for NEXT, R. for RETURN; No ? for PRINT

No implicit GOTO after THEN

PRINT does not accept semicolon

Primarily interactive commands are excluded (RUN, CONT, LIST, LOAD etc.)

RESTORE accepts label

No line length limit

Negative STEP allowed in FOR loops

Minus sign has lower precedence than power

PI is a built-in variable
