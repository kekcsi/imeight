Stack based RISC

SSx where x: 0..F -- select stack (memory address $Fx00 to $FxFF, $Fx00 holds the top index)

PSM addr[X] -- push (from memory address to the selected stack)
PSB byte -- push byte
PUL addr[X] -- pull (from the selected stack to memory address)

PLX -- pull to index register (X)
INX -- increment X
DEX -- decrement X
PSX -- push from index register

JSR addr -- push instruction pointer to stack F and jump to address
RTS -- pull two bytes from stack F and jump there

JPZ byte -- jump if top of selected stack equals zero
JNZ byte -- jump if top of selected stack is not zero
JPN byte -- jump if top of selected stack is negative
JNN byte -- jump if top of selected stack is nonnegative

ADC -- add with carry (pull top two bytes from the stack and push their sum)
SBC -- subtract with borrow
MUL -- multiply, push two bytes
DIV -- divide, also push modulo
AND -- bitwise and
ORA -- bitwise or
EOR -- bitwise exclusive or
ASL -- arithmetic shift left
ASR -- arithmetic shift right
ROL -- bit rotation left
ROR -- bit rotation right
NEG -- arithmetic negation
INC -- increment
DEC -- decrement
NOT -- bitwise not

STC -- set carry flag
CLC -- clear carry flag
