<html>
<head>
    <script type="text/javascript" src="imeight_pl.js"></script>
    <style>
    	#inUserInput, #taList {
    		border: none;
    		background:transparent;
    		padding: 0;
    		margin: 0;
    		font-family: monospace;
    		font-size: 13px;
    	}

    	#inUserInput:focus, #taList:focus {
    		outline: none;
    		background:transparent;
    		padding: 0;
    		margin: 0;
    	}
    	
    	div.dark, #taList, div.dark input {
    		background: black;
    		color: orange;
    		resize: none;
    	}
    	
    	.dark ::-webkit-scrollbar {
    		width: 12px;
    	}
    	 
    	.dark ::-webkit-scrollbar-track {
    		background: black; 
    	}
    	 
    	.dark ::-webkit-scrollbar-thumb {
    		background: orange; 
    	}
    	
    	button.glow, button.glow:focus {
    		background: orange;
    		color: black;
    		padding: 0 2em;
    		border: 0 none;
    		margin: 0;
    		font-weight: bold;
    	}
    	
    	button.tab {
    		background: silver;
    		color: black;
    		padding: 4px 8px;
    		border: 2px 2px 0 2px;
    		margin: 0 4px 0 0;
    		font-weight: normal;
    		font-family: sans-serif;
    	}
    	
    	.win {
    		background: silver;
    		padding: 4px;
    		width: 600px;
    		font-size: 13px;
    	}
    	
    	#inputButtons {
    		position: absolute;
    		right: 0px;
    		font-size: 8px;
    	}
    	
    	#tabScreen {
    		position: relative;
    		height: 320px;
    		padding-bottom: 2px;
    	}
    	
    	#divTutor {
    		position: fixed;
    		top: 0;
    		left: 624px;
    		width: 600px;
    		height: 357px;
    	}
    </style>
</head>
<body onload="pageLoad()">
    <div class="win">
    	<button id="btnProgram" onclick="programTab()" class="tab" style="border:inset">Program Listing</button>
    	<button id="btnScreen" onclick="screenTab()" class="tab" style="border:outset">Interactive Screen</button>
    	<div class="dark" id="tabProgram">
    		<textarea rows="20" cols="80" id="taList"></textarea><br/>
    		<button class="glow" onclick="parseText()" title="Test Run Program on the Interactive Screen (F9)">TOKENIZE+RELINK</button>
    		<button class="glow" onclick="commands.OLD()" title="Restore Program Text After NEW or OLD Command">OLD</button>
    		<button class="glow" onclick="divTutor.style.display='block'" title="Show Tutorial (F1)">TUTOR</button>
    	</div>
    	<div class="dark" id="tabScreen" style="display:none">
    		<div class="dark" id="divOutput" style="font-family:Monospace">
    		</div>
    		<input size="64" id="inUserInput"/>
    		<span id="inputButtons">
    			<button class="glow" onclick="userInput()" id="btnGo">&#x2713;</button>
    			<button class="glow" onclick="userBreak()" id="btnStop">&#x2715;</button>
    		</span>
    	</div>
    </div>
    <div id="divTutor" style="display:none" class="win">
    	<textarea rows="20" cols="80" id="taTutor">
-- PRINT --

    PRINT "HELLO WORLD"
    REMARK: The PRINT instruction is for learning and debugging purposes only.
    REMARK: Press TOKENIZE+RELINK (F9) then enter RUN interactive command.
    REMARK: See "HELLO WORLD" printed as a result.
    REMARK: Return to the Program Listing by entering the LIST command.
    REMARK: NEW instead of LIST command will also erase the program text.

An Infix Operator: + Between Numbers

    PRINT 6+4
    REMARK: See 10 printed on the Interactive Screen.
    REMARK: + is an infix operator and works like in maths.
    REMARK: There are more operators to be covered in the Expressions part of this tutorial.

A Function: SIN

    PRINT SIN(1.571)
    REMARK: 1.571 is approximately 90 degrees in radians. So this will print a number close to 1, sine of 90 degrees.
    REMARK: You must not leave white space between SIN and the parenthesis.



-- INPUT --

Full Syntax

    INPUT "HOW MUCH?", A
    REMARK: Again an instruction for learning purposes only. Displays the question "HOW MUCH?". User may enter the value.

Default Prompt

    INPUT A
    REMARK: A shorter version of the INPUT instruction. Also displays a prompt window but the question is generated by the runner.

The Normal Program Flow

    INPUT A
    PRINT A
    INPUT B
    PRINT B
    REMARK: Now we wrote a program of multiple lines. The topmost line will run first. Program waits while the user is entering the value for A.
    REMARK: Then the second line runs so the value of the variable A is printed to the log.
    REMARK: See that whatever is entered is printed. It's because INPUT instruction has assigned the entered value to the variable A, which kept that value when printed.
    REMARK: Third and fourth line does the same with another variable, B. INPUT B happens after printing A, as if you would read a story.

Assignment: Old Value, New Value

    INPUT A
    PRINT A
    INPUT A
    PRINT A
    REMARK: In the previous example A kept its value. Now here is an example how it can drop the value. Read the story.
    REMARK: First line, INPUT A prompts the user and assigns the entered value to A. Variable A will keep it for the next line.
    REMARK: To prove it, we do a PRINT A in the 2nd line. In the 3rd line INPUT will assign again. Which means, the old value
    REMARK: is replaced by the new. See what gets logged in the 4th line: the new value of A, regardless of its previous value.



-- Names --

In the INPUT examples we could see that there are variables named A and B, which help us store numbers.
But you can name them relatively freely. Let's see the exact rules for naming variables and more:

(1) A variable name must start with a letter A through Z. They may have a longer name.

(2) From the second position on, the name may contain digits 0 to 9 or more letters, or both, in any order.

(3) There is no length limit for the name.

(4) The name optionally ends in one $ or one % sign.
Convention is that the name ends in $ if it is supposed to have a text value rather than number.
The % sign suggests integer number value.

These rules not only apply to variable names, but also function names and array names, which are covered later.



-- LET --

    LET SUM = 6+4
    PRINT SUM
    REMARK: The first line will assign a calculated value, 10, to the variable SUM.
    REMARK: Second line shows that the variable keeps the value.
    REMARK: This way you can give a name to your calculation results, making your intent clear and the code maintainable.

Implicit LET Instruction

    SUM = 6+4
    PRINT SUM
    REMARK: You can omit the instruction LET and it will still be interpreted as an assignment.
    REMARK: Line 1 is not an equation. The left side must specify the thing to assign to (variable A this time.)

Motivation
    
    SUM = 1+1+1+1+1+1+1+1+1+1
    LITTLEBIGGER = SUM+1
    MUCHBIGGER = SUM+10
    PRINT SUM
    PRINT LITTLEBIGGER
    PRINT MUCHBIGGER
    REMARK: Let's pretend that calculating SUM takes a lot of time and effort.
    REMARK: This is how you reuse a calculation. The SUM variable keeps its value and is used for calculating two more values.
    REMARK: So variables are not only there for code readability, they can make your code more efficient, too.

Referencing The Old Value In LET

    INPUT A
    A = A+1
    PRINT A
    REMARK: 2nd line says, add 1 to the old value of A, and let the incremented value be the new value of A.
    REMARK: So the 3rd line will print the successor of whatever the user enters.



-- REM, The Colon, Spaces: Your Readable Code --

You can make your code self documented by inserting REM instrucions. They make the runner ignore the rest of the line.

    REM * USER WILL ENTER A NUMBER *
    INPUT A
    REM * COMPUTER WILL INCREMENT THE NUMBER *
    A = A+1
    REM * AND NOW DISPLAY THE RESULT *
    PRINT A
    
You can use this instruction to temporarily skip a line or two while developing your program:

    PRINT "HELLO"
    REM PRINT "GOODBYE"
    REM * I HAVE COMMENTED OUT THE SECOND LINE *
    REM *    RUNS LIKE IT WAS DELETED BUT      *
    REM * MAYBE I WILL WANT TO UNCOMMENT LATER *

You can normally put several instructions on a line, separated by colon:

    PRINT "HELLO":PRINT "WORLD":REM BOTH WILL PRINT

But the colon does not break the REM instruction:

    PRINT "THIS PRINTS":REM HERE IS A REMARK:PRINT "STILL PART OF THE REM, NOT PRINTING"

The REMARK lines in the examples before are also REM instructions.
The space after the REM or any instruction is optional, so the text starting with ARK had been ignored by the runner.
But you should keep your code readable, which means spaces are good for you.



-- Expressions --

    A$ = "THIS TEXT BETWEEN QUOTES IS A LITERAL, A SIMPLE EXPRESSION."
    A = 30:REM THE NUMBER IS ALSO A LITERAL, WHICH IS AN EXPRESSION
    SUM = A+1:REM A CALCULATION WITH AN OPERATOR IS AN EXPRESSION (SUM = IS NOT PART OF THE EXPRESSION)
    PRINT A+1:REM EXPRESSION MAY APPEAR IN ASSIGNMENT RIGHT SIDE AS WELL AS PRINT ARGUMENT
    PRINT A$:REM THE VARIABLE NAME BECOMES AN EXPRESSION IF ON THE RIGHT SIDE OR AS PRINT ARGUMENT
    INPUT A$, C$:REM OR ARGUMENT TO INSTRUCTIONS OTHER THAN PRINT
    Y = SIN(1 + 0.571):REM COMBINATION OF FUNCTIONS AND OPERATORS BUILD EXPRESSIONS, TOO
    Z = SIN(4.712)+2:REM COMBINE THEM FREELY LIKE IN MATHS



String Expressions

(A) The String Literal

    A$ = "HELLO WORLD"
    PRINT "HELLO WORLD"
    PRINT A$
    REM *     THE QUOTED "HELLO WORLD" IS CALLED LITERAL     *
    REM * BECAUSE IT ASSIGNS, PRINTS "HELLO WORLD" LITERALLY *
    REM *        WHEREAS A$ IS NOT A LITERAL BECAUSE         *
    REM * IT PRINTS "HELLO WORLD" RATHER THAN "A$" LITERALLY *

(B) Concatenation

    PRINT "HELLO" + "WORLD"
    REM * PLUS BETWEEN STRING LITERALS MEANS CONCATENATION *
    REM *   PRINTS "WORLD" IMMEDIATELY FOLLOWING "HELLO"   *
    
    GREETING$ = "HELLO"
    AUDIENCE$ = "WORLD"
    PRINT GREETING$ + " " + AUDIENCE$
    REM * CONCATENATION OF STRING VARIABLES AND LITERALS ALSO WORKS *
    
(C) String Functions
    
    PRINT LEN("HOW LONG AM I"):REM PRINTS 13 (10 LETTERS + 3 SPACES)
    PRINT "1" + "2":REM DOES NOT PRINT 3 BUT A CONCATENATED STRING "12"
    PRINT VAL("1") + VAL("2"):REM PRINTS 3
    PRINT ASC("A"):REM PRINTS THE ASCII CODE 65
    PRINT CHR$(65):REM PRINTS "A" BEACUSE ITS ASCII CODE IS 65
    PRINT LEFT$("HELLO", 3):REM PRINTS "HEL" - 3 CHARACTERS FROM THE LEFT
    PRINT RIGHT$("HELLO", 3):REM PRINTS "LLO" - 3 CHARACTERS FROM THE RIGHT
    PRINT MID$("HELLO", 2, 3):REM PRINTS "ELL" - 3 CHARACTERS FROM THE 2ND POSITION
    REM *  THE COMMA IS AN OPERATOR HERE THAT MAKES A PARAMETER LIST  * 
    REM * IT'S ON THE LOWEST PRECEDENCE LEVEL AMONG ALL THE OPERATORS *



Numeric Expressions

    'Examples below are for your reference, not error free programs to run.

(A) Literals

    MOL = 6.022E+23:REM E MEANS "TIMES 10 TO THE POWER"
    A = 10:REM DECIMAL 10, REALLY TEN
    B = %10:REM BINARY 10, MEANING TWO
    C = $10:REM HEXADECIMAL 10, MEANING SIXTEEN
    D = !10:REM FOUR-BASE 10, MEANING FOUR
    E = 1.2:REM 1 AND 2 TENTHS
    F = .2:REM 2 TENTHS
    G = .2E-2:REM 0.002

(B) Operators

    C = A+B:REM ADD
    C = A-B:REM SUBTRACT
    C = A*B:REM MULTIPLY
    C = A/B:REM DIVIDE
    C = A^B:REM POWER
    C = A AND B:REM BITWISE LOGICAL AND; SPACE IS NECESSARY AFTER A
    C = A OR B:REM BITWISE LOGICAL OR; SPACE IS NECESSARY AFTER A

(C) Functions

    REM * SOME INTERESTING THINGS THAT TECHNICALLY ARE FUNCTIONS *
    Y = -X:REM UNARY MINUS, MEANING (-1)*X
    Y = A*(B+C):REM THE PARENTHESIS IS A FUNCTION WITHOUT A NAME - RETURNS WHAT IS INSIDE
    
    REM * BASIC MATHS *
    Y = SGN(X):REM -1 FOR A NEGATIVE X, 0 FOR 0, 1 FOR A POSITIVE X
    Y = INT(X):REM INTEGER PART OF X, BUT STAYS FLOATING POINT
    Y = ABS(X):REM ABSOLUTE VALUE: -X IF X<0, OTHERWISE X
    Y = SQR(X):REM SQUARE ROOT
    
    REM * TRANSCENDENT *
    Y = LOG(X):REM NATURAL LOGARITHM
    Y = EXP(X):REM NATURAL EXPONENTIAL FUNCTION
    
    REM * TRIGONOMETRY *
    Y = COS(X):REM COSINE
    Y = SIN(X):REM SINE
    Y = TAN(X):REM TANGENT
    Y = ATN(X):REM ARC TANGENT	

    REM * COMPUTING *
    Y = NOT(X):REM BITWISE LOGICAL NEGATION
    Y = INT%(X):REM INTEGER VALUE OF X, STORED IN A 16-BIT FIXED WORD
    Y = RND(X):REM NON-NEGATIVE RANDOM NUMBER THAT IS LESS THAN X
    Y = PEEK(X):REM THE BYTE STORED IN MEMORY AT ADDRESS X; SPOILER - STORE ONE USING POKE INSTRUCTION
    Y$ = STR$(X):REM A DECIMAL REPRESENTATION OF THE NUMBER X



About Evaluation

    PRINT RND(8) - RND(8):REM RND FUNCTION GETS EVALUATED TWICE, PROBABLY RETURNS DIFFERENT VALUES
    
    X = RND(8):REM EVALUATED ONCE
    PRINT X - X:REM ALWAYS RETURNS ZERO



-- GOTO --

Flow instructions can break the normal flow of the program. GOTO instructs the runner to immediately go to a specified
point in the program, rather than continuing at the next one in reading order. Using the @ instruction you can put a
label to a point in the program and reference that label in a GOTO argument.

Jumping over a part of the program:

    PRINT "TITLE"
    PRINT "INTRODUCTION"
    GOTO RESULTS
    REM NOONE CARES ABOUT CALCULATIONS
    PRINT "CALCULATIONS"
    @RESULTS
    PRINT "RESULTS"

Jumping back makes an endless loop:

    @LOOP
    INPUT A
    GOTO LOOP
    REM * THIS WILL RUN UNTIL USER CANCELS *
    
Jumping wildly:

    PRINT "THEY SAY GOTO IS A CRIME"
    GOTO INTERMEZZO
    @CONTINUATION
    PRINT "CAN WE CONCLUDE, GOTO IS FUN?"
    GOTO FIN
    @INTERMEZZO
    PRINT "I SAY GOTO IS FINE"
    GOTO CONTINUATION
    @FIN



-- IF and THEN --

Logical Operators

    INPUT A
    REM * EQUAL AND UNEQUAL SIGNS ARE OPERATORS, TOO: *
    REM * THEY APPEAR BETWEEN TWO NUMERIC EXPRESSIONS *
    REM *  AND GIVE 1 AS RESULT IF TRUE, 0 IF FALSE   *
    IF A=1 THEN PRINT "A IS ONE"
    IF A<>2 THEN PRINT "A IS NOT TWO"
    IF A<10 THEN PRINT "A IS LESS THAN TEN"
    IF A>5 THEN PRINT "A IS GREATER THAN FIVE"
    IF A<=8 THEN PRINT "A IS NOT GREATER THAN EIGHT"
    IF A>=7 THEN PRINT "A IS NOT LESS THAN SEVEN"
    REM * AND IS AN OPERATOR, JUST LIKE OR *
    IF A>=4 AND A<=6 THEN PRINT "A IS BETWEEN FOUR AND SIX"
    IF A<3 OR A>9 THEN PRINT "A IS NOT BETWEEN THREE AND NINE"

Mixing Logic and Numbers

    REM * TRUE CONVERTS TO 1, FALSE TO 0 IF COMPARISON RESULT IS USED IN NUMERIC EXPRESSION *
    REM * WHEN NUMERIC EXPRESSION IS USED AS A CONDITION, 0 MEANS FALSE, NON-0 NUMBERS TRUE *
    INPUT "PLEASE ENTER 1 HERE.", A
    IF 1-A THEN PRINT "BAD"
    IF 1-A<>0 THEN PRINT "BAD"
    IF 1<>A THEN PRINT "BAD"
    REM * IF USER DOES NOT ENTER 1 THEN "BAD" APPEARS THREE TIMES *
    REM * IF USER ENTERS 1 THEN PROGRAM ENDS WITHOUT PRINTING     *

Pitfalls

    REM * OPERATORS AND, OR WORK BITWISE                                                               *
    REM * AS LONG AS THE TWO SIDES OF THEM ARE EITHER 0 OR 1, THEY CAN BE USED TO COMBINE CONDITIONS   *
    REM * COMPARISON OPERATORS LIKE < AND > AND = WILL GIVE EITHER 0 OR 1 TO SUPPORT SUCH COMBINATIONS *
    REM * HOWEVER, NOT FUNCTION IS BITWISE AND MAY HAVE ASTONISHING RESULT                             *
    INPUT A:INPUT B
    IF NOT(A=B) THEN PRINT "A IS NOT B?"
    REM * ENTER EQUAL NUMBERS                                         *
    REM * A=B GIVES 1 (TRUE). NOT(A=B) GIVES ALL BITS BUT ONE SET, -2 *
    REM * IT IS NOT 0, CONDITION IS MET, MESSAGE WILL BE PRINTED      *

    PRINT 0=0=0:REM 0 (FALSE) BECAUSE 0=0 GIVES 1 (TRUE), 1=0 GIVES 0 (FALSE)
    PRINT 0=0=1:REM 1 (TRUE) BECAUSE 0=0 GIVES 1 (TRUE), 1=1 GIVES 1 (TRUE)
    
Colon After THEN

    @TASK
    A = INT(RND(10))
    B = INT(RND(10))
    @ASK
    INPUT A + " + " + B, C
    IF C = A+B THEN PRINT "CORRECT":GOTO TASK
    PRINT "TRY AGAIN":GOTO ASK
    REM * IF THE USER IS RIGHT THEN THE PROGRAM WILL NOT ONLY PRINT "CORRECT" BUT ALSO GOTO TASK *
    REM * IF THE CONDITION IS NOT MET THEN THE REST OF THE LINE IS SKIPPED, EVEN IF IT CONTAINS  *
    REM * SEVERAL INSTRUCTIONS SEPARATED WITH COLON                                              *



-- Operator Summary --

Precedence

    REM ^            	    LEVEL 1
    PRINT 2 * 3^2:REM 18
    PRINT (2*3)^2:REM 36
    REM / *          	    LEVEL 2
    PRINT 1 + 2*3:REM 7
    PRINT (1+2)*3:REM 9
    REM + -          	    LEVEL 3
    PRINT 6 < 10+2:REM 1
    PRINT (6<10)+2:REM 3
    REM <> >= > <= < 	    LEVEL 4
    PRINT 2 = 4<>3:REM 0
    PRINT (2=4)<>3:REM 1
    REM =            	    LEVEL 5
    PRINT 1 AND 3 = 1:REM 0
    PRINT (1 AND 3)=1:REM 1
    REM AND          	    LEVEL 6
    PRINT 1 OR 3 AND 2:REM 3
    PRINT (1 OR 3)AND 2:REM 2
    REM OR           	    LEVEL 7
    PRINT 1, 2 OR 4:REM [1, 6]
    REM , 			 	    LEVEL 8

    REM * OTHER OPERATORS ON THE SAME PRECEDENCE LEVELS *
    PRINT 18 / 3^2:REM 2
    PRINT 6 + 4/2:REM 8
    PRINT 6 - 4/2:REM 4
    PRINT 6 < 10-2:REM 1
    PRINT 9 > 10-2:REM 1
    PRINT 8 <= 10-2:REM 1
    PRINT 8 >= 10-2:REM 1
    PRINT 1 = 4>3:REM 1
    PRINT 3 = 3<2:REM 0
    PRINT 1 = 4>=4:REM 1
    PRINT 0 = 1<=1:REM 0
    
Associativity
    
    REM * ALL OPERATORS LEFT-ASSOCIATIVE (INCLUDING POWER, UNLIKE IN MATHS) *
    PRINT 2^3^2:REM 64
    PRINT 2^(3^2):REM 512
    PRINT 100/20/5:REM 1
    PRINT 100/(20/5):REM 25
    PRINT 100-20-5:REM 75
    PRINT 100-(20-5):REM 85
    PRINT 3>2>1:REM 0 (FALSE) BECAUSE 3>2 GIVES 1 (TRUE), 1>1 GIVES 0 (FALSE)
    PRINT 3>(2>1):REM 1 (TRUE) BECAUSE 2>1 GIVES 1 (TRUE), 3>1 GIVES 1 (TRUE)
    
The Unary Minus Sign

    REM * UNARY MINUS HAS LOWER PRECEDENCE THAN POWER *
    PRINT -2^2:REM -4
    PRINT (-2)^2:REM 4
    REM * UNARY MINUS HAS HIGHER PRECEDENCE THAN ADD OR SUBTRACT *
    PRINT -2+2:REM 0
    PRINT -(2+2):REM -4



-- GOSUB and RETURN --

    PRINT "VERSE 1"
    GOSUB CHORUS:REM GO TO THE SUBPROGRAM AT @CHORUS BUT COME BACK WHEN IT'S DONE
    PRINT "VERSE 2"
    GOSUB CHORUS:REM NOTE THAT THE SAME SUBPROGRAM CAN RETURN HERE, TOO
    GOTO OUTRO
    @CHORUS: PRINT "CHORUS"
    RETURN:REM SUBPROGRAM OVER, GO BACK TO THE POINT AFTER GOSUB (THE RIGHT GOSUB)
    @OUTRO: PRINT "OUTRO"
    


-- END and STOP --

    PRINT "VERSE 1"
    GOSUB CHORUS
    PRINT "VERSE 2"
    GOSUB CHORUS
    PRINT "OUTRO"
    END:REM PREVENTS RUNNING THE CHORUS AGAIN
    @CHORUS: PRINT "CHORUS"
    RETURN
    
    INPUT R
    IF R<=0 THEN STOP
    PRINT R^2*3.14159
    REM * THE RUNNER CAN TELL IF THE PROGRAM STOPPED WITH ERROR OR ENDED NORMALLY *
    
    PRINT "STEP 1"
    STOP
    PRINT "STEP 2"
    STOP
    PRINT "STEP 3"
    REM * ENTER INTERACTIVE COMMAND CONT TO CONTINUE *
    REM * ENTER INTERACTIVE COMMAND RUN TO START OVER *



-- FOR and NEXT --

Wanna do something 10 times?

    FOR I=1 TO 10:PRINT "THIS OLD MAN, HE PLAYED " + I:NEXT

What more can FOR loops do?
    
    FOR I=0 TO 9
    	A$ = " "
    	REM * ANOTHER LOOP INSIDE THE LOOP         *
    	REM * THE END OF THE LOOP IS AN EXPRESSION *
    	REM * THE COUNTER J WILL STEP DOWN         *
    	FOR J=9 TO 9-I STEP -1
    		A$ = A$ + J
    	NEXT
    	PRINT A$
    NEXT I
    REM * THIS SYNTAX OF NEXT MAKES SURE THAT IT ENDS THE CORRECT LOOP: IF  *
    REM * THE PROGRAM FLOW ACCIDENTALLY HITS IT WHEN THERE IS NO LOOP FOR I *
    REM * THEN INSTEAD OF CONTINUING THE WRONG FLOW, IT IMMEDIATELY STOPS   *
    
    REM * BREAKING THE LOOP EARLY *
    INPUT CUT
    FOR I=1 TO 10
    	PRINT I
    	IF I = CUT THEN I = 30:NEXT:GOTO OUT
    	PRINT "POTATO"
    NEXT
    @OUT
    PRINT "STEAK"
    
    FOR I=10 TO 45 STEP 10:PRINT I:NEXT
    PRINT "LOOP EXITED WITH " + I
    REM * I NEVER GETS EXACTLY 45, LAST CYCLE STARTS WITH I=40, EXITS WITH I=50 *

-- DATA and READ --

    REM * READ ASSIGNS THE NEXT VALUE FROM THE DATA LINE TO ITS ARGUMENT *
    FOR I=1 TO 5:READ A:PRINT A:NEXT
    DATA 2,3,5,7,11

    READ A:READ B:A=9:READ C
	PRINT A,B,C
    DATA RND(8)
    DATA A, A + 1
    REM * EVALUATION ORDER: ON READ A, FIRST DATA LINE IS EVALUATED, A RANDOM NUMBER GETS GENERATED. *
    REM * ON READ B, SECOND DATA LINE EVALUATES (BOTH ELEMENTS OF IT AT ONCE.) NOW VARIABLE A HOLDS  *
    REM * THE RANDOMIZED NUMBER, SO B GETS THE SAME VALUE AS A. THEN A=9 ASSIGNMENT HAPPENS.         *
    REM * C GETS THE ALREADY EVALUATED VALUE, WHICH IS THE RANDOM NUMBER PLUS 1 (THE NEW VALUE OF A, *
    REM * 9, DOES NOT AFFECT C'S.)                                                                   *
    


-- RESTORE --

Restore to the beginning

    GOSUB POEM
    PRINT "*"
    GOSUB POEM
    END
    @POEM
    RESTORE
    REM * RESTORE INSTRUCTION MAKES SURE THE POEM STARTS WITH THE FIRST LINE *
    REM *      NO MATTER HOW MANY TIMES THE PROGRAM RUNS THE SUBPROGRAM      *
    FOR LINE=1 TO 5:READ L$:PRINT L$:NEXT LINE
    RETURN
    DATA "THERE WAS AN OLD MAN WITH A BEARD,"
    DATA "WHO SAID, 'IT IS JUST AS I FEARED!"
    DATA "TWO OWLS AND A HEN,", "FOUR LARKS AND A WREN,"
    DATA "HAVE ALL BUILT THEIR NESTS IN MY BEARD!'"
    
Restore to a label

    RESTORE WEEKEND
    FOR I=1 TO 14
    	READ DAY$:PRINT DAY$ + " " + I
    	IF DAY$ = "SUN" THEN RESTORE
    NEXT
    END
    DATA "MON", "TUE", "WED", "THU", "FRI"
    @WEEKEND: DATA "SAT", "SUN"



-- DIM --

    REM * BUBBLE SORT *
    DIM ARRAY(10)
    INPUT ARRAY(0)
    FOR I=1 TO 9
    	READ ARRAY(I)
    NEXT
	PRINT "ARRAY IN ASCENDING ORDER:"
    FOR K=8 TO 0 STEP -1
    	FOR I=0 TO K
    		IF ARRAY(I)>ARRAY(I + 1) THEN NEXT I:GOTO OUT
    		SWAP = ARRAY(I)
    		ARRAY(I) = ARRAY(I + 1)
    		ARRAY(I + 1) = SWAP
    	NEXT I
    	@OUT
    	PRINT ARRAY(I)
    NEXT K
    PRINT ARRAY(0)
    END
    DATA 1, 2, 3, 5, 9, 8, 7, 4, 6



-- POKE --

Store a byte in the memory by address.

    POKE 5000,6
    REM 5000 IS THE ADDRESS, 6 IS THE BYTE
    PRINT PEEK(5000)



-- CLR --

Clear all variables and arrays. Built-in variables restored.

    PI = 3.0
    PRINT PI
    CLR
    PRINT PI

Bytes in memory survive a CLR.

    POKE 5000,6
    CLR
    PRINT PEEK(5000):REM 6



-- DEF --

    LOG2 = LOG(2)
    DEF LOG2(X) = LOG(X)/LOG2
    X=10
    PRINT LOG2(32)
    PRINT X
    
CLR will erase user-defined functions, too.

    DEF TWICE(N) = 2*N
    DIM ARRAY(10)
    CLR
    DIM TWICE(10):REM NOT AN OVERDEFINITION
    DEF ARRAY(N) = 2*N:REM NOT AN OVERDEFINITION



-- ON --

    INPUT "CHOOSE FROM MENU 1-3", CHOICE
    ON CHOICE GOTO M1, M2, M3
    @M1: PRINT "YOU CHOSE #1"
    END
    @M2: PRINT "YOU CHOSE #2"
    END
    @M3: PRINT "YOU CHOSE #3"
    END

    @START
    INPUT "CHOOSE FROM MENU 1-3", CHOICE
    ON CHOICE GOSUB M1, M2, M3
    GOTO START
    @M1: PRINT "YOU CHOSE #1"
    RETURN
    @M2: PRINT "YOU CHOSE #2"
    RETURN
    @M3: PRINT "YOU CHOSE #3"
    RETURN



-- Multidimensional Arrays --

    DIM MANCALA(6,2)
    MANCALA(4,1) = 0
    MANCALA(5,1) = MANCALA(4,1)+1



-- Non-Unary Functions --

Nullary

    D12 = RND(12)+1
    PRINT D12
    REM * GIVES 12 JUST AS OFTEN AS 7 *
    CLR
    D12 = RND(6)+RND(6)+2
    REM * RANDOM WITH THE DISTRIBUTION OF ROLLING 2 REGULAR DICE *
    PRINT D12
    PRINT D12
    PRINT D12
    REM * EVALUATION HAPPENS ONCE, SAME NUMBER IS PRINTED 3 TIMES *
    CLR
    DEF D12()=RND(6)+RND(6)+2
    REM * NULLARY FUNCTION *
    PRINT D12()
    PRINT D12()
    PRINT D12()
    REM * ROLLS THREE TIMES *

Higher Arities

    DEF MAX(A,B)=(A>=B)*A+(A<B)*B
    PRINT MAX(-3,MAX(5/2,8/4))



-- I/O: OPEN, CLOSE, GET, WAIT --



-- Abbreviations --

    REM * T. IS SHORT FOR THEN *
    REM * G. IS SHORT FOR GOTO *
    REM * N. IS SHORT FOR NEXT *
    REM * R. STANDS FOR RETURN *
    'OH, AND YOU CAN USE APOSTROPHE INSTEAD OF REM INSTRUCTION
    INPUT "ENTER REQUESTED INDIAN COUNT", N 'NO NEED FOR A COLON
    IF N>10 T.G.HANDLER
    S$=""
    FOR I=1 TO N
    	GOSUB INDIAN
    	S$="S"
    N.
    END
    @HANDLER: 
    	PRINT "TOO MANY INDIANS"
    	STOP
    @INDIAN: 
    	PRINT I+" LITTLE INDIAN"+S$
    	R.



-- Run Time Errors --

NO VALUE

    CLR
    PRINT NOSUCH
    
    DATA XX+1, YY+1
    XX=0
    READ Y:REM TRIES TO EVALUATE THE WHOLE DATA LINE, INCLUDING YY+1
    YY=0:REM TOO LATE
    
    DIM A$(8)
    A$(1) = ""
    PRINT A$(1):REM FINE
    PRINT A$(2):REM NO VALUE. MAKE SURE YOU INITIALIZE ALL MEMBERS OF YOUR ARRAY BEFORE USE
    
    A=8
    PRINT A:REM FINE
    A=
    REM * VARIABLE A IS NOW UNASSIGNED *
    PRINT A:REM NO VALUE

INVALID REFERENCE

    CLR
    INPUT UNARRAY(0)
    
    SIN(0) = 0

NEXT WITHOUT FOR

    FOR I=0 TO 10
    	IF I=5 THEN I=10:NEXT
    	REM *     WHAT HAPPENS WHEN I=5? IF CONDITION MET, I GETS 10    *
    	REM *    NEXT ABOVE WILL TERMINATE THE LOOP AND CONTINUE HERE   *
    	REM * THE OTHER NEXT WILL ALSO RUN BUT THERE IS NO LOOP ANYMORE *
    NEXT
    
RETURN WITHOUT GOSUB

    GOSUB SUB
    REM * NOTE: AFTER RETURNING FROM THE SUB, PROGRAM CONTINUES HERE *
    @SUB
    RETURN

LOOP MISMATCH

    FOR I=1 TO 10:NEXT J

BREAK

    INPUT X:REM USER PRESSES CANCEL BUTTON

OVERDEFINITION

    DIM SIN(10)
    
    DEF FN(PM)=-PM
    DIM FN(10)
    
    DIM ARR(10)
    DEF ARR(X)=-X

OUT OF DATA

    REM * OOPS, OFF BY ONE *
    FOR I=0 TO 10:READ X:NEXT
    DATA 1, 2, 3, 4, 5, 6, 7, 8, 9, 10

LABEL DOES NOT EXIST

    GOTO PI
    
    GOSUB PI
    
    RESTORE PI

NO DATA AT LABEL

    RESTORE LABEL
    @LABEL:PRINT "NOT A DATA INSTRUCTION"
    DATA 1

BRANCH

    A = 100
    ON A GOTO L1, L2
    @L1
    @L2
    
DIVIDE BY ZERO

    A = 1/0



-- Contrasting C64 --

Dollar or percent sign at the end of names is a convention

    A% = "HELLO"
    A$ = 3
    REM * BOTH WORK *
    
The full name of the variable identifies

    VAR1 = 1:VAR2 = 2:REM TWO DISTINCT VARIABLES HERE
    PRINT VAR1,VAR2

Use spaces to separate names from operators

    SCORE = 30
    SC = 1:E = 2
    PRINT SCORE:REM 30
    PRINT SC OR E:REM 3
		</textarea>
    	<div>
    		<button onclick="divTutor.style.display='none'">HIDE</button>
    	</div>
    </div>
</body>		
</html>